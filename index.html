<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portal Shader</title>
    <link rel="stylesheet" href="https://use.typekit.net/xxxxxxx.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <style>
        @font-face {
            font-family: 'Automate OT';
            src: local('Automate OT'), local('AutomateOT');
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            background: #ffffff !important;
        }
        body {
            background: #ffffff !important;
            min-height: 100vh;
            overflow-x: hidden;
            font-family: 'Automate OT', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            z-index: 300;
        }
        .logo {
            font-weight: 700;
            font-size: 18px;
            letter-spacing: 2px;
            color: #000;
        }
        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .cart-icon {
            width: 24px;
            height: 24px;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }
        .cart-icon:hover {
            opacity: 1;
        }
        .hamburger {
            width: 44px;
            height: 44px;
            cursor: pointer;
            z-index: 300;
            position: relative;
            transition: filter 0.2s ease;
        }
        #hamburgerLottie {
            width: 100%;
            height: 100%;
            filter: brightness(0);
        }
        .hamburger:hover #hamburgerLottie {
            filter: brightness(0) sepia(1) hue-rotate(180deg) saturate(5);
        }
        .hamburger.open:hover #hamburgerLottie {
            filter: brightness(0) sepia(1) hue-rotate(-30deg) saturate(10);
        }

        /* Menu Overlay */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.85);
            z-index: 250;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .menu-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .menu-overlay a {
            font-size: 32px;
            font-weight: 300;
            color: #000;
            text-decoration: none;
            margin: 20px 0;
            letter-spacing: 4px;
            transition: opacity 0.2s ease;
        }
        .menu-overlay a:hover {
            opacity: 0.5;
        }

        /* Footer / Social Icons */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 24px;
            padding: 20px;
            z-index: 200;
        }
        .social-icon {
            width: 24px;
            height: 24px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s ease;
        }
        .social-icon:hover {
            opacity: 1;
        }

        /* Product Display */
        .product-section {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            pointer-events: none;
        }
        .product-carousel {
            width: 100%;
            overflow: hidden;
            pointer-events: all;
            touch-action: pan-x;
        }
        .product-track {
            display: flex;
            transition: transform 0.3s ease;
        }
        .product-item {
            min-width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .product-shape {
            width: 220px;
            height: 220px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .product-shape svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 4px 20px rgba(255, 255, 255, 0.3));
        }

        /* Product Info */
        .product-info {
            position: fixed;
            bottom: 80px;
            left: 0;
            right: 0;
            text-align: center;
            z-index: 150;
            padding: 0 20px;
            mix-blend-mode: difference;
        }
        .product-name {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 2px;
            margin-bottom: 8px;
            color: #fff;
        }
        .product-price {
            font-size: 16px;
            font-weight: 400;
            color: #fff;
        }

        /* Swipe indicators */
        .swipe-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 15px;
            pointer-events: all;
            mix-blend-mode: difference;
        }
        .swipe-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .swipe-dot.active {
            background: rgba(255, 255, 255, 1);
        }

        /* Nav arrows (desktop) */
        .nav-arrow {
            display: none;
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            outline: none;
            color: #fff;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 24px;
            transition: opacity 0.2s ease;
            align-items: center;
            justify-content: center;
            z-index: 200;
            mix-blend-mode: difference;
            pointer-events: all;
            opacity: 0.7;
        }
        .nav-arrow:hover {
            opacity: 1;
        }
        .nav-arrow.prev {
            left: calc(50% - 200px);
        }
        .nav-arrow.next {
            right: calc(50% - 200px);
        }

        /* Portal */
        .portal-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        canvas {
            display: block;
            width: calc(90vw + 1in);
            max-width: 500px;
            height: calc(75vh + 1in);
            max-height: 850px;
            background: transparent;
        }

        /* ========== DESKTOP STYLES ========== */
        @media (min-width: 768px) {
            /* Header - horizontal nav */
            .header {
                padding: 30px 50px;
            }
            .logo {
                font-size: 22px;
            }
            .hamburger {
                display: none;
            }
            .header-nav {
                display: flex;
                gap: 40px;
            }
            .header-nav a {
                font-size: 14px;
                font-weight: 500;
                color: #000;
                text-decoration: none;
                letter-spacing: 2px;
                opacity: 0.7;
                transition: opacity 0.3s ease;
            }
            .header-nav a:hover {
                opacity: 1;
            }
            .cart-icon {
                width: 28px;
                height: 28px;
            }
            .menu-overlay {
                display: none;
            }

            /* Product hover effects */
            .product-item {
                cursor: pointer;
                transition: transform 0.3s ease;
            }
            .product-shape {
                transition: transform 0.3s ease;
            }
            .product-shape svg {
                transition: filter 0.3s ease, transform 0.3s ease;
            }
            .product-item:hover .product-shape {
                transform: scale(1.1);
            }
            .product-item:hover .product-shape svg {
                filter: drop-shadow(0 8px 40px rgba(255, 255, 255, 0.6));
            }

            /* Swipe dots hover */
            .swipe-dot {
                transition: background 0.2s ease, transform 0.2s ease;
            }
            .swipe-dot:hover {
                transform: scale(1.3);
            }

            /* Nav arrows visible on desktop */
            .nav-arrow {
                display: flex;
            }

            /* Footer */
            .footer {
                gap: 32px;
                padding: 30px;
            }
            .social-icon {
                width: 28px;
                height: 28px;
                transition: opacity 0.3s ease, transform 0.3s ease;
            }
            .social-icon:hover {
                transform: translateY(-3px);
            }

            /* Larger portal on desktop */
            canvas {
                width: 70vw;
                max-width: 700px;
                height: 80vh;
                max-height: 900px;
            }
        }

        /* Large desktop */
        @media (min-width: 1200px) {
            .header {
                padding: 40px 80px;
            }
            canvas {
                max-width: 800px;
                max-height: 1000px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">LOGO</div>
        <nav class="header-nav">
            <a href="#about">ABOUT</a>
            <a href="#shop">SHOP</a>
            <a href="#contact">CONTACT</a>
        </nav>
        <div class="header-right">
            <svg class="cart-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="9" cy="21" r="1"></circle>
                <circle cx="20" cy="21" r="1"></circle>
                <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
            </svg>
            <div class="hamburger" onclick="toggleMenu()">
                <div id="hamburgerLottie"></div>
            </div>
        </div>
    </header>

    <!-- Menu Overlay -->
    <div class="menu-overlay" id="menuOverlay">
        <a href="#cart">CART</a>
        <a href="#about">ABOUT</a>
    </div>

    <!-- Product Carousel (above portal) -->
    <div class="product-section">
        <div class="product-carousel" id="productCarousel">
            <div class="product-track" id="productTrack">
                <div class="product-item">
                    <div class="product-shape">
                        <svg viewBox="0 0 100 100" fill="none" stroke="white" stroke-width="2">
                            <circle cx="50" cy="50" r="40"/>
                        </svg>
                    </div>
                </div>
                <div class="product-item">
                    <div class="product-shape">
                        <svg viewBox="0 0 100 100" fill="none" stroke="white" stroke-width="2">
                            <rect x="15" y="15" width="70" height="70"/>
                        </svg>
                    </div>
                </div>
                <div class="product-item">
                    <div class="product-shape">
                        <svg viewBox="0 0 100 100" fill="none" stroke="white" stroke-width="2">
                            <polygon points="50,10 90,85 10,85"/>
                        </svg>
                    </div>
                </div>
            </div>
        </div>
        <div class="swipe-dots">
            <div class="swipe-dot active" onclick="goToProduct(0)"></div>
            <div class="swipe-dot" onclick="goToProduct(1)"></div>
            <div class="swipe-dot" onclick="goToProduct(2)"></div>
        </div>
    </div>

    <!-- Nav Arrows (desktop) -->
    <button class="nav-arrow prev" onclick="prevProduct()">&lt;</button>
    <button class="nav-arrow next" onclick="nextProduct()">&gt;</button>

    <!-- Product Info -->
    <div class="product-info">
        <div class="product-name" id="productName">CIRCLE</div>
        <div class="product-price" id="productPrice">$49.00</div>
    </div>

    <!-- Portal -->
    <div class="portal-container">
        <canvas id="glCanvas"></canvas>
    </div>

    <!-- Footer / Social Icons -->
    <footer class="footer">
        <!-- Instagram -->
        <svg class="social-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
            <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
            <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>
        </svg>
        <!-- Twitter/X -->
        <svg class="social-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 4l11.5 16h4.5l-11.5-16z"></path>
            <path d="M4 20l6.5-6.5"></path>
            <path d="M20 4l-6.5 6.5"></path>
        </svg>
        <!-- Email -->
        <svg class="social-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
            <polyline points="22,6 12,13 2,6"></polyline>
        </svg>
    </footer>

    <script>
        // Tilt/Parallax values (used by both mouse and IMU)
        let tiltX = 0;
        let tiltY = 0;
        let targetTiltX = 0;
        let targetTiltY = 0;
        let hasPermission = false;
        let isDesktop = window.innerWidth >= 768;

        // Smooth interpolation for parallax
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        // Mouse movement handler (desktop)
        function handleMouseMove(event) {
            if (!isDesktop) return;
            // Normalize mouse position to -1 to 1
            targetTiltX = (event.clientX / window.innerWidth - 0.5) * 2;
            targetTiltY = (event.clientY / window.innerHeight - 0.5) * 2;
        }

        // Add mouse listener for desktop
        document.addEventListener('mousemove', handleMouseMove);

        // Update on resize
        window.addEventListener('resize', () => {
            isDesktop = window.innerWidth >= 768;
        });

        // IMU / Device Orientation (mobile)
        function handleOrientation(event) {
            if (isDesktop) return;
            // gamma is left/right tilt (-90 to 90)
            // beta is front/back tilt (-180 to 180)
            targetTiltX = (event.gamma || 0) / 90; // normalize to -1 to 1
            targetTiltY = (event.beta || 0) / 180; // normalize to -1 to 1
        }

        // iOS 13+ requires permission request
        function requestIMUPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permission => {
                        if (permission === 'granted') {
                            hasPermission = true;
                            window.addEventListener('deviceorientation', handleOrientation);
                        }
                    })
                    .catch(console.error);
            } else {
                // Non-iOS or older iOS
                hasPermission = true;
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }

        // Request on first tap anywhere
        document.addEventListener('click', function initIMU() {
            if (!hasPermission && !isDesktop) {
                requestIMUPermission();
            }
        }, { once: false });

        // Try to init immediately for non-iOS
        if (typeof DeviceOrientationEvent !== 'undefined' &&
            typeof DeviceOrientationEvent.requestPermission !== 'function') {
            window.addEventListener('deviceorientation', handleOrientation);
            hasPermission = true;
        }

        // Smooth tilt update loop
        function updateTilt() {
            tiltX = lerp(tiltX, targetTiltX, 0.08);
            tiltY = lerp(tiltY, targetTiltY, 0.08);
            requestAnimationFrame(updateTilt);
        }
        updateTilt();

        // Product data
        const products = [
            { name: 'CIRCLE', price: '$49.00' },
            { name: 'SQUARE', price: '$59.00' },
            { name: 'TRIANGLE', price: '$69.00' }
        ];

        let currentProduct = 0;
        let startX = 0;
        let currentX = 0;
        let isDragging = false;

        const track = document.getElementById('productTrack');
        const carousel = document.getElementById('productCarousel');
        const productName = document.getElementById('productName');
        const productPrice = document.getElementById('productPrice');
        const dots = document.querySelectorAll('.swipe-dot');

        function updateProduct(index) {
            currentProduct = index;
            track.style.transform = `translateX(-${index * 100}%)`;
            productName.textContent = products[index].name;
            productPrice.textContent = products[index].price;
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });
        }

        function goToProduct(index) {
            updateProduct(index);
        }

        function prevProduct() {
            if (currentProduct > 0) {
                updateProduct(currentProduct - 1);
            }
        }

        function nextProduct() {
            if (currentProduct < products.length - 1) {
                updateProduct(currentProduct + 1);
            }
        }

        // Touch events
        carousel.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            isDragging = true;
            track.style.transition = 'none';
        });

        carousel.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            currentX = e.touches[0].clientX;
            const diff = currentX - startX;
            const offset = -currentProduct * 100;
            const percentDiff = (diff / carousel.offsetWidth) * 100;
            track.style.transform = `translateX(calc(${offset}% + ${diff}px))`;
        });

        carousel.addEventListener('touchend', (e) => {
            isDragging = false;
            track.style.transition = 'transform 0.3s ease';
            const diff = currentX - startX;

            if (Math.abs(diff) > 50) {
                if (diff > 0 && currentProduct > 0) {
                    updateProduct(currentProduct - 1);
                } else if (diff < 0 && currentProduct < products.length - 1) {
                    updateProduct(currentProduct + 1);
                } else {
                    updateProduct(currentProduct);
                }
            } else {
                updateProduct(currentProduct);
            }
        });

        // Menu toggle with Lottie
        let menuOpen = false;
        const hamburgerAnim = lottie.loadAnimation({
            container: document.getElementById('hamburgerLottie'),
            renderer: 'svg',
            loop: false,
            autoplay: false,
            path: 'hamburger.json'
        });

        function toggleMenu() {
            const hamburger = document.querySelector('.hamburger');
            const menu = document.getElementById('menuOverlay');

            if (!menuOpen) {
                // Play first half: hamburger -> X (frames 0-40)
                hamburgerAnim.playSegments([0, 40], true);
                menu.classList.add('active');
                hamburger.classList.add('open');
            } else {
                // Play second half: X -> hamburger (frames 40-84)
                hamburgerAnim.playSegments([40, 84], true);
                menu.classList.remove('active');
                hamburger.classList.remove('open');
            }
            menuOpen = !menuOpen;
        }

        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
        }

        // Vertex shader
        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

        // Fragment shader
        const fsSource = `
            #ifdef GL_ES
            precision mediump float;
            #endif

            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec2 u_tilt;

            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution.xy;
                vec2 pos = st * 2.0 - 1.0;
                pos.x *= u_resolution.x / u_resolution.y;

                // Rectangle dimensions
                float width = 0.375;
                float height = 0.625;
                float cornerRadius = 0.07;

                // WOBBLY EDGES - distort the position for edge calculation
                float wobbleAmt = 0.008;
                float wobbleFreq = 8.0;
                float wobbleSpeed = 1.5;
                vec2 wobble = vec2(
                    sin(pos.y * wobbleFreq + u_time * wobbleSpeed) * wobbleAmt,
                    sin(pos.x * wobbleFreq + u_time * wobbleSpeed * 1.1) * wobbleAmt
                );

                // Calculate distance for each RGB channel with chromatic offset
                float caEdge = 0.006;

                vec2 posR = pos + wobble - vec2(caEdge, 0.0);
                vec2 dR = abs(posR) - vec2(width, height);
                float distR = length(max(dR, 0.0)) + min(max(dR.x, dR.y), 0.0) - cornerRadius;

                vec2 posG = pos + wobble;
                vec2 dG = abs(posG) - vec2(width, height);
                float distG = length(max(dG, 0.0)) + min(max(dG.x, dG.y), 0.0) - cornerRadius;

                vec2 posB = pos + wobble + vec2(caEdge, 0.0);
                vec2 dB = abs(posB) - vec2(width, height);
                float distB = length(max(dB, 0.0)) + min(max(dB.x, dB.y), 0.0) - cornerRadius;

                // Signed distance to rounded rectangle (use green for main inside check)
                float dist = distG;

                // Inside rectangle = black with stars, outside = white
                float insideR = smoothstep(0.01, 0.0, distR);
                float insideG = smoothstep(0.01, 0.0, distG);
                float insideB = smoothstep(0.01, 0.0, distB);
                float inside = insideG;

                // Start with black for rectangle interior
                vec3 starColor = vec3(0.0);

                // CENTER PULSING LINE - vertical only
                if (inside > 0.5) {
                    float pulse = sin(u_time * 2.0) * 0.5 + 0.5;
                    float lineThickness = 0.004;

                    // Vertical center line
                    float vDist = abs(pos.x);
                    float vLine = smoothstep(lineThickness, 0.0, vDist) * pulse;

                    // Add line (green tint)
                    starColor.g += vLine * 0.15;
                }

                // GRID LINES shrinking inward (underneath everything)
                if (inside > 0.5) {
                    for (int i = 0; i < 12; i++) {
                        float fi = float(i);

                        // Stagger each grid's start time
                        float cycleOffset = fi / 12.0;
                        float gridSpeed = 0.15;
                        float t = fract(cycleOffset + u_time * gridSpeed);

                        // Start at edge, shrink toward center
                        float scale = 1.0 - t;

                        // Grid spacing shrinks with scale
                        float vGridSpacing = 0.1 * scale;
                        float hGridSpacing = 0.15 * scale;  // Different spacing for horizontal
                        float gridLineThickness = 0.001;

                        if (vGridSpacing > 0.01) {
                            // Apply parallax to grid based on scale (closer grids move more)
                            vec2 gridPos = pos + u_tilt * scale * 0.08;

                            // Vertical lines
                            float vDist = abs(mod(gridPos.x + vGridSpacing * 0.5, vGridSpacing) - vGridSpacing * 0.5);
                            float vLine = smoothstep(gridLineThickness, 0.0, vDist);

                            // Horizontal lines with offset to avoid center
                            float hOffset = 0.04; // offset away from center
                            float hDist = abs(mod(gridPos.y + hOffset + hGridSpacing * 0.5, hGridSpacing) - hGridSpacing * 0.5);
                            float hLine = smoothstep(gridLineThickness, 0.0, hDist);

                            float grid = max(hLine, vLine);

                            // Fade out toward center
                            float fade = pow(scale, 6.0);

                            // Chromatic aberration
                            float caOffset = 0.003;
                            float vDistR = abs(mod(gridPos.x + caOffset + vGridSpacing * 0.5, vGridSpacing) - vGridSpacing * 0.5);
                            float hDistR = abs(mod(gridPos.y + hOffset + caOffset + hGridSpacing * 0.5, hGridSpacing) - hGridSpacing * 0.5);
                            float gridR = max(smoothstep(gridLineThickness, 0.0, vDistR), smoothstep(gridLineThickness, 0.0, hDistR));

                            float vDistB = abs(mod(gridPos.x - caOffset + vGridSpacing * 0.5, vGridSpacing) - vGridSpacing * 0.5);
                            float hDistB = abs(mod(gridPos.y + hOffset - caOffset + hGridSpacing * 0.5, hGridSpacing) - hGridSpacing * 0.5);
                            float gridB = max(smoothstep(gridLineThickness, 0.0, vDistB), smoothstep(gridLineThickness, 0.0, hDistB));

                            // Very transparent - dots should be brightest
                            starColor.r += gridR * fade * 0.15;
                            starColor.g += grid * fade * 0.15;
                            starColor.b += gridB * fade * 0.15;
                        }
                    }
                }

                // RECTANGLE OUTLINES emitting from rim, shrinking inward
                if (inside > 0.5) {
                    for (int i = 0; i < 24; i++) {
                        float fi = float(i);

                        // Stagger each ring's start time - much closer together
                        float cycleOffset = fi / 24.0;
                        float speed = 0.2;
                        float t = fract(cycleOffset + u_time * speed);

                        // Start at edge (scale 1.0), shrink toward center (scale 0.0)
                        float scale = 1.0 - t;

                        // Current rectangle size
                        float ringWidth = width * scale;
                        float ringHeight = height * scale;
                        float ringCorner = cornerRadius * scale;

                        // Signed distance to this ring's rounded rectangle
                        vec2 ringD = abs(pos) - vec2(ringWidth, ringHeight);
                        float ringDist = length(max(ringD, 0.0)) + min(max(ringD.x, ringD.y), 0.0) - ringCorner;

                        // Line thickness - gets thinner as it moves inward
                        float lineThickness = 0.004 * scale + 0.001;
                        float ring = smoothstep(lineThickness, 0.0, abs(ringDist));

                        // Brightness - extreme fade, only see ~4 lines from edge
                        float brightness = pow(scale, 8.0) * 2.0;

                        // Fade in at start, very aggressive fade out
                        float fadeIn = smoothstep(0.0, 0.02, t);
                        float fadeOut = smoothstep(0.4, 0.0, t);
                        float fade = fadeIn * fadeOut;

                        // Chromatic aberration on rings - split the difference
                        float caOffset = 0.014 * (1.0 - scale + 0.3);

                        // Red ring - slightly larger
                        vec2 ringDR = abs(pos) - vec2(ringWidth + caOffset, ringHeight + caOffset);
                        float ringDistR = length(max(ringDR, 0.0)) + min(max(ringDR.x, ringDR.y), 0.0) - ringCorner;
                        float ringR = smoothstep(lineThickness, 0.0, abs(ringDistR));

                        // Blue ring - slightly smaller
                        vec2 ringDB = abs(pos) - vec2(ringWidth - caOffset, ringHeight - caOffset);
                        float ringDistB = length(max(ringDB, 0.0)) + min(max(ringDB.x, ringDB.y), 0.0) - ringCorner;
                        float ringB = smoothstep(lineThickness, 0.0, abs(ringDistB));

                        // Subtle bloom
                        float bloom = exp(-abs(ringDist) * 50.0) * 0.12;

                        starColor.r += (ringR * brightness + bloom) * fade * 0.2;
                        starColor.g += (ring * brightness + bloom) * fade * 0.2;
                        starColor.b += (ringB * brightness + bloom) * fade * 0.2;
                    }
                }

                // WARP STARS - only inside the rectangle
                if (inside > 0.5) {
                    for (int i = 0; i < 150; i++) {
                        float fi = float(i);

                        // Pseudo-random seed for each star
                        float seed1 = fract(sin(fi * 127.1) * 43758.5453);
                        float seed2 = fract(sin(fi * 269.5) * 18756.234);
                        float seed3 = fract(sin(fi * 419.2) * 28934.123);

                        // Star position in normalized space
                        float starX = (seed1 - 0.5) * 2.0;
                        float starY = (seed2 - 0.5) * 2.0;

                        // Each star has its own cycle offset for continuous flow
                        float cycleOffset = seed3;
                        float speed = 0.15;

                        // Z depth - each star starts at different point in cycle
                        float z = fract(cycleOffset + u_time * speed);

                        // Project star position based on z (perspective)
                        float scale = 1.0 / (z + 0.1);
                        vec2 starPos = vec2(starX, starY) * scale * 0.1;

                        // Apply parallax based on tilt - closer stars move more
                        float parallaxStrength = (1.0 - z) * 0.15;
                        starPos += u_tilt * parallaxStrength;

                        // Star size grows as it gets closer
                        float starSize = (1.0 - z) * 0.008 + 0.001;

                        // Star brightness increases as it approaches
                        float brightness = (1.0 - z);

                        // Chromatic aberration offset - more separation
                        float caOffset = 0.02 * length(starPos);
                        vec2 caDir = normalize(starPos);

                        // Red channel - offset outward
                        vec2 posR = pos - caDir * caOffset;
                        float distR = length(posR - starPos);
                        float starR = smoothstep(starSize, 0.0, distR) * brightness;
                        float bloomR = exp(-distR * 80.0) * brightness * 0.15;

                        // Green channel - center
                        float distG = length(pos - starPos);
                        float starG = smoothstep(starSize, 0.0, distG) * brightness;
                        float bloomG = exp(-distG * 100.0) * brightness * 0.1;

                        // Blue channel - offset inward
                        vec2 posB = pos + caDir * caOffset;
                        float distB = length(posB - starPos);
                        float starB = smoothstep(starSize, 0.0, distB) * brightness;
                        float bloomB = exp(-distB * 80.0) * brightness * 0.15;

                        // GLARE - horizontal and vertical streaks
                        vec2 delta = pos - starPos;
                        float glareLen = 0.06 * brightness;
                        float hGlare = exp(-abs(delta.y) * 300.0) * exp(-abs(delta.x) / glareLen) * brightness * 0.15;
                        float vGlare = exp(-abs(delta.x) * 300.0) * exp(-abs(delta.y) / glareLen) * brightness * 0.15;
                        float glare = hGlare + vGlare;

                        // Chromatic glare
                        vec2 deltaR = posR - starPos;
                        vec2 deltaB = posB - starPos;
                        float glareR = exp(-abs(deltaR.y) * 300.0) * exp(-abs(deltaR.x) / glareLen) * brightness * 0.1;
                        float glareB = exp(-abs(deltaB.y) * 300.0) * exp(-abs(deltaB.x) / glareLen) * brightness * 0.1;

                        starColor.r += starR + bloomR + glare + glareR;
                        starColor.g += starG + bloomG + glare;
                        starColor.b += starB + bloomB + glare + glareB;
                    }
                }

                // HUD ELEMENTS
                if (inside > 0.5) {
                    // SCANNING LINE - sweeps up and down
                    float scanSpeed = 0.5;
                    float scanY = sin(u_time * scanSpeed) * height * 0.8;
                    float scanLine = smoothstep(0.004, 0.0, abs(pos.y - scanY)) * 0.2;
                    starColor += vec3(scanLine * 0.5, scanLine, scanLine * 0.8);

                    // 3. FILM GRAIN/NOISE
                    float grain = fract(sin(dot(pos + u_time, vec2(12.9898, 78.233))) * 43758.5453);
                    starColor += vec3(grain * 0.04);

                    // 6. BINARY RAIN - vertical streaks
                    for (int i = 0; i < 12; i++) {
                        float fi = float(i);
                        float rainX = (fract(sin(fi * 234.5) * 5765.3) - 0.5) * width * 2.0;
                        float rainSpeed = 0.3 + fract(sin(fi * 567.8) * 2345.6) * 0.4;
                        float rainY = fract(u_time * rainSpeed + fract(sin(fi * 789.1) * 3456.7)) * height * 2.0 - height;
                        float rainLen = 0.03 + fract(sin(fi * 123.4) * 6789.0) * 0.04;

                        float inRain = step(rainY, pos.y) * step(pos.y, rainY + rainLen);
                        float rainDist = abs(pos.x - rainX);
                        float rain = smoothstep(0.002, 0.0, rainDist) * inRain * 0.25;
                        starColor.g += rain;
                        starColor.b += rain * 0.5;
                    }

                    // 10. ENERGY FIELD - pulsing glow around edges
                    float edgeDist = min(min(pos.x + width, width - pos.x), min(pos.y + height, height - pos.y));
                    float energyPulse = sin(u_time * 3.0) * 0.5 + 0.5;
                    float energyField = exp(-edgeDist * 15.0) * energyPulse * 0.15;
                    starColor += vec3(energyField * 0.6, energyField, energyField * 0.8);

                    // 13. LENS DUST/PARTICLES - floating specks
                    for (int p = 0; p < 8; p++) {
                        float fp = float(p);
                        float px = sin(u_time * 0.1 + fp * 1.5) * width * 0.8;
                        float py = cos(u_time * 0.08 + fp * 2.1) * height * 0.8;
                        float pDist = length(pos - vec2(px, py));
                        float particle = smoothstep(0.008, 0.003, pDist) * 0.15;
                        starColor += vec3(particle);
                    }

                    // 15. CHROMATIC PULSE - periodic color shift wave
                    float pulseWave = sin(pos.y * 10.0 - u_time * 2.0) * 0.5 + 0.5;
                    float pulseTrigger = smoothstep(0.8, 1.0, sin(u_time * 0.3));
                    starColor.r += pulseWave * pulseTrigger * 0.08;
                    starColor.b += (1.0 - pulseWave) * pulseTrigger * 0.08;
                }

                // White background, black rectangle with chromatic edges
                vec3 color;
                color.r = mix(1.0, starColor.r, insideR);
                color.g = mix(1.0, starColor.g, insideG);
                color.b = mix(1.0, starColor.b, insideB);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Create program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(shaderProgram));
        }

        // Setup buffers
        const positions = new Float32Array([
            -1.0,  1.0,
             1.0,  1.0,
            -1.0, -1.0,
             1.0, -1.0,
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // Get attribute and uniform locations
        const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
        const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
        const timeUniformLocation = gl.getUniformLocation(shaderProgram, 'u_time');
        const tiltUniformLocation = gl.getUniformLocation(shaderProgram, 'u_tilt');

        // Resize canvas for mobile
        function resizeCanvas() {
            const maxWidth = 500;
            const maxHeight = 850;
            const vw = window.innerWidth * 0.9;
            const vh = window.innerHeight * 0.75;

            canvas.width = Math.min(vw, maxWidth);
            canvas.height = Math.min(vh, maxHeight);
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Render loop
        let startTime = Date.now();

        function render() {
            const currentTime = (Date.now() - startTime) / 1000.0;

            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(shaderProgram);

            // Set uniforms
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
            gl.uniform1f(timeUniformLocation, currentTime);
            gl.uniform2f(tiltUniformLocation, tiltX, tiltY);

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
